import * as cdk from 'aws-cdk-lib';
import * as s3 from 'aws-cdk-lib/aws-s3';
import * as s3deploy from 'aws-cdk-lib/aws-s3-deployment';
import * as cloudfront from 'aws-cdk-lib/aws-cloudfront';
import * as origins from 'aws-cdk-lib/aws-cloudfront-origins';
import * as apigateway from 'aws-cdk-lib/aws-apigateway';
import * as lambda from 'aws-cdk-lib/aws-lambda';
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
<% if (auth) { %>import * as cognito from 'aws-cdk-lib/aws-cognito';<% } %>
import * as iam from 'aws-cdk-lib/aws-iam';
import { Construct } from 'constructs';
import * as path from 'path';

export interface AppStackProps extends cdk.StackProps {
  appId: string;
  appName: string;
  environment: 'dev' | 'prod';
}

export class AppStack extends cdk.Stack {
  constructor(scope: Construct, id: string, props: AppStackProps) {
    super(scope, id, props);

    const { appId, appName, environment } = props;

    // S3 Bucket for web hosting
    const webBucket = new s3.Bucket(this, 'WebBucket', {
      bucketName: `${appName.toLowerCase()}-${environment}-web-${this.account}`,
      // Dev: use public S3 website hosting (fast, no CloudFront)
      // Prod: use CloudFront with OAC (secure, cached)
      publicReadAccess: environment === 'dev',
      blockPublicAccess: environment === 'dev'
        ? s3.BlockPublicAccess.BLOCK_ACLS
        : s3.BlockPublicAccess.BLOCK_ALL,
      websiteIndexDocument: environment === 'dev' ? 'index.html' : undefined,
      websiteErrorDocument: environment === 'dev' ? 'index.html' : undefined,
      removalPolicy: environment === 'dev' ? cdk.RemovalPolicy.DESTROY : cdk.RemovalPolicy.RETAIN,
      autoDeleteObjects: environment === 'dev',
    });

    // CloudFront Distribution - ONLY for production (dev uses S3 website)
    let distribution: cloudfront.Distribution | undefined;
    if (environment === 'prod') {
      distribution = new cloudfront.Distribution(this, 'Distribution', {
        defaultBehavior: {
          origin: origins.S3BucketOrigin.withOriginAccessControl(webBucket),
          viewerProtocolPolicy: cloudfront.ViewerProtocolPolicy.REDIRECT_TO_HTTPS,
          cachePolicy: cloudfront.CachePolicy.CACHING_OPTIMIZED,
        },
        defaultRootObject: 'index.html',
        errorResponses: [
          {
            httpStatus: 404,
            responseHttpStatus: 200,
            responsePagePath: '/index.html',
          },
          {
            httpStatus: 403,
            responseHttpStatus: 200,
            responsePagePath: '/index.html',
          },
        ],
      });
    }

    // Deploy web assets to S3
    new s3deploy.BucketDeployment(this, 'WebDeployment', {
      sources: [s3deploy.Source.asset(path.join(__dirname, '../../web/out'))],
      destinationBucket: webBucket,
      distribution, // undefined for dev, CloudFront for prod
      distributionPaths: distribution ? ['/*'] : undefined,
    });

    <% if (auth) { %>
    // Cognito User Pool
    const userPool = new cognito.UserPool(this, 'UserPool', {
      userPoolName: `${appName}-${environment}`,
      selfSignUpEnabled: true,
      signInAliases: {
        email: true,
      },
      autoVerify: {
        email: true,
      },
      passwordPolicy: {
        minLength: 8,
        requireLowercase: true,
        requireUppercase: true,
        requireDigits: true,
        requireSymbols: false,
      },
      removalPolicy: environment === 'dev' ? cdk.RemovalPolicy.DESTROY : cdk.RemovalPolicy.RETAIN,
    });

    const userPoolClient = new cognito.UserPoolClient(this, 'UserPoolClient', {
      userPool,
      authFlows: {
        userPassword: true,
        userSrp: true,
      },
    });
    <% } %>

    <% spec.dataModel.forEach(function(model) { %>
    // DynamoDB Table: <%= model.table %>
    const <%= model.table.toLowerCase() %>Table = new dynamodb.Table(this, '<%= model.table %>Table', {
      tableName: `${appName}-${environment}-<%= model.table %>`,
      partitionKey: {
        name: '<%= model.partitionKey %>',
        type: dynamodb.AttributeType.STRING,
      },
      <% if (model.sortKey) { %>
      sortKey: {
        name: '<%= model.sortKey %>',
        type: dynamodb.AttributeType.STRING,
      },
      <% } %>
      billingMode: dynamodb.BillingMode.PAY_PER_REQUEST,
      removalPolicy: environment === 'dev' ? cdk.RemovalPolicy.DESTROY : cdk.RemovalPolicy.RETAIN,
      pointInTimeRecovery: environment === 'prod',
    });
    <% if (model.secondaryIndexes && model.secondaryIndexes.length > 0) { %>
    <% model.secondaryIndexes.forEach(function(index) { %>
    <%= model.table.toLowerCase() %>Table.addGlobalSecondaryIndex({
      indexName: '<%= index.name %>',
      partitionKey: {
        name: '<%= index.partitionKey %>',
        type: dynamodb.AttributeType.STRING,
      },
      <% if (index.sortKey) { %>
      sortKey: {
        name: '<%= index.sortKey %>',
        type: dynamodb.AttributeType.STRING,
      },
      <% } %>
      projectionType: dynamodb.ProjectionType.<%= index.projectionType || 'ALL' %>,
    });
    <% }); %>
    <% } %>
    <% }); %>

    // Lambda execution role
    const lambdaRole = new iam.Role(this, 'LambdaRole', {
      assumedBy: new iam.ServicePrincipal('lambda.amazonaws.com'),
      managedPolicies: [
        iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AWSLambdaBasicExecutionRole'),
      ],
    });

    // Grant DynamoDB permissions
    <% spec.dataModel.forEach(function(model) { %>
    <%= model.table.toLowerCase() %>Table.grantReadWriteData(lambdaRole);
    <% }); %>

    // Environment variables for Lambda
    const lambdaEnvironment: Record<string, string> = {
      ENVIRONMENT: environment,
      APP_NAME: appName,
      <% spec.dataModel.forEach(function(model) { %>
      <%= model.table.toUpperCase() %>_TABLE: <%= model.table.toLowerCase() %>Table.tableName,
      <% }); %>
      <% if (auth) { %>
      USER_POOL_ID: userPool.userPoolId,
      USER_POOL_CLIENT_ID: userPoolClient.userPoolClientId,
      <% } %>
    };

    <% spec.api.forEach(function(endpoint) { %>
    // Lambda: <%= endpoint.handler %>
    const <%= endpoint.handler %>Fn = new lambda.Function(this, '<%= endpoint.handler %>Function', {
      runtime: lambda.Runtime.NODEJS_20_X,
      handler: 'handlers/<%= endpoint.handler %>.handler',
      code: lambda.Code.fromAsset(path.join(__dirname, '../../api')),
      role: lambdaRole,
      environment: lambdaEnvironment,
      timeout: cdk.Duration.seconds(30),
      memorySize: 256,
    });
    <% }); %>

    // API Gateway
    const api = new apigateway.RestApi(this, 'Api', {
      restApiName: `${appName}-${environment}`,
      description: `API for ${appName} (${environment})`,
      deployOptions: {
        stageName: environment,
        throttlingRateLimit: 100,
        throttlingBurstLimit: 200,
      },
    });

    <% if (auth) { %>
    // Cognito Authorizer
    const authorizer = new apigateway.CognitoUserPoolsAuthorizer(this, 'Authorizer', {
      cognitoUserPools: [userPool],
    });
    <% } %>

    // Track created resources to add CORS preflight
    const createdResources = new Set<string>();

    <% spec.api.forEach(function(endpoint) { %>
    // API Route: <%= endpoint.method %> <%= endpoint.path %>
    {
      const parts = '<%= endpoint.path %>'.split('/').filter(p => p);
      let resource: apigateway.IResource = api.root;
      let resourcePath = '';

      for (const part of parts) {
        resourcePath += '/' + part;
        const existing = resource.getResource(part);
        resource = existing || resource.addResource(part);

        // Add CORS preflight to each resource (only once)
        if (!createdResources.has(resourcePath)) {
          resource.addCorsPreflight({
            allowOrigins: ['*'],
            allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
            allowHeaders: ['Content-Type', 'Authorization'],
          });
          createdResources.add(resourcePath);
        }
      }

      resource.addMethod('<%= endpoint.method %>', new apigateway.LambdaIntegration(<%= endpoint.handler %>Fn)<% if (auth && endpoint.requiresAuth) { %>, {
        authorizer,
        authorizationType: apigateway.AuthorizationType.COGNITO,
      }<% } %>);
    }
    <% }); %>

    // Outputs
    new cdk.CfnOutput(this, 'WebBucketName', {
      value: webBucket.bucketName,
      description: 'S3 bucket for web hosting',
    });

    if (distribution) {
      new cdk.CfnOutput(this, 'DistributionId', {
        value: distribution.distributionId,
        description: 'CloudFront distribution ID',
      });

      new cdk.CfnOutput(this, 'DistributionDomain', {
        value: distribution.distributionDomainName,
        description: 'CloudFront distribution domain',
      });

      new cdk.CfnOutput(this, 'ProdUrl', {
        value: `https://${distribution.distributionDomainName}`,
        description: 'Production URL',
      });
    }

    // Dev uses S3 website URL (fast), Prod uses CloudFront (secure + cached)
    if (environment === 'dev') {
      new cdk.CfnOutput(this, 'PreviewUrl', {
        value: webBucket.bucketWebsiteUrl,
        description: 'Preview URL (S3 website)',
      });
    }

    new cdk.CfnOutput(this, 'ApiUrl', {
      value: api.url,
      description: 'API Gateway URL',
    });

    <% if (auth) { %>
    new cdk.CfnOutput(this, 'UserPoolId', {
      value: userPool.userPoolId,
      description: 'Cognito User Pool ID',
    });

    new cdk.CfnOutput(this, 'UserPoolClientId', {
      value: userPoolClient.userPoolClientId,
      description: 'Cognito User Pool Client ID',
    });
    <% } %>

    <% spec.dataModel.forEach(function(model) { %>
    new cdk.CfnOutput(this, '<%= model.table %>TableName', {
      value: <%= model.table.toLowerCase() %>Table.tableName,
      description: 'DynamoDB table: <%= model.table %>',
    });
    <% }); %>
  }
}
